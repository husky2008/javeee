#观察线程池处理的流程处理的
我们通过一些例子，来观察一下其内部的处理逻辑。基于上述具体代码，我们已经创建了一个核心线程数4，最大线程数8，线程存活时间10s，工作队列最大容量为10的一个线程池。
初始化线程池：未添加线程任务

这时，线程池中不会创建任何线程，存活线程为0，工作队列为0.
未达核心线程数：添加4个线程任务

由于当前存活线程数 <= 核心线程数，所以会创建新的线程。即存活线程为4，工作队列为0.
核心线程数已满：添加第5个线程任务

若当前线程池中存在空闲线程，则交由该线程处理。即存活线程为4，工作队列为0.
若当前所有线程处理运行状态，加入工作队列。即存活线程为4，工作队列为1.（注意：此时工作队列中的任务不会被执行，直到有线程空闲后，才能被处理）
工作队列未满：假设添加的任务都是耗时操作（短时间不会结束），再添加9个耗时任务

即存活线程为4，工作队列为10.
工作队列已满 & 未达最大线程数：再添加4个任务

当工作队列已满，且不存在空闲线程，此时会创建额外线程来处理当前任务。此时存活线程为8，工作队列为10.
工作队列已满 & 且最大线程数已满：再添加1个任务

触发RejectedExecutionHandler，将当前任务交由自己设置的执行句柄进行处理。此时存活线程为8，工作队列为10.
当任务执行完后，没有新增的任务，临时扩充的线程（大于核心线程数的）将在10s（keepAliveTime）后被销毁